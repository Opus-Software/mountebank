#!/usr/bin/env node

'use strict';

const mountebank = require('../src/mountebank'),
    fs = require('fs'),
    path = require('path'),
    http = require('http'),
    Q = require('q'),
    ejs = require('ejs'),
    yargs = require('yargs');

function error (message) {
    console.error(`${message}\n`);
    yargs.showHelp();
    process.exit(1);
}

function processExists (pid) {
    try {
        // "As a special case, signal 0 can be used to test existence of process"
        // https://nodejs.org/api/process.html#process_process_kill_pid_signal
        process.kill(pid, 0);
        return true;
    }
    catch (e) {
        return false;
    }
}

function shouldLoadConfigFile (options) {
    return typeof options.configfile !== 'undefined';
}

function putConfig (options, body) {
    const deferred = Q.defer(),
        requestOptions = {
            method: 'PUT',
            path: '/imposters',
            port: options.port,
            hostname: options.host || 'localhost',
            headers: {
                'Content-Type': 'application/json',
                Connection: 'close'
            }
        },

        request = http.request(requestOptions, response => {
            response.body = '';
            response.setEncoding('utf8');
            response.on('data', chunk => { response.body += chunk; });
            response.on('end', () => {
                response.body = JSON.parse(response.body);
                deferred.resolve(response);
            });
        });

    request.on('error', deferred.reject);

    request.write(body);
    request.end();
    return deferred.promise;
}

function getConfig (options) {
    const deferred = Q.defer(),
        requestOptions = {
            method: 'GET',
            path: '/imposters?replayable=true',
            port: options.port,
            hostname: options.host || 'localhost',
            headers: {
                'Content-Type': 'application/json',
                Connection: 'close'
            }
        };

    if (options.removeProxies) {
        requestOptions.path += '&removeProxies=true';
    }

    const request = http.request(requestOptions, response => {
        response.body = '';
        response.setEncoding('utf8');
        response.on('data', chunk => { response.body += chunk; });
        response.on('end', () => {
            deferred.resolve(response);
        });
    });

    request.on('error', deferred.reject);

    request.end();
    return deferred.promise;
}

// usage: stringify(includeFile)
// note: Trying to make this backwards compatible. However, the intent is to change
// the signature to just require `includeFile`.
function stringify (filename, includeFile) {
    const resolvedPath = makePathInABackwardsCompatibleWay(filename, includeFile);
    const contents = fs.readFileSync(resolvedPath, 'utf8'),
        rendered = ejs.render(contents, {
            filename: CONFIG_FILE_PATH,
            stringify: stringify,
            inject: stringify // backwards compatibility
        }),
        jsonString = JSON.stringify(rendered.trim());

    // get rid of the surrounding quotes because it makes the templates more natural to quote them there
    return jsonString.substring(1, jsonString.length - 1);
}

function makePathInABackwardsCompatibleWay (filename, includeFile) {
    var resolvedPath = null;
    if (!includeFile) {
        includeFile = filename;
    }
    resolvedPath = path.join(path.dirname(CONFIG_FILE_PATH), includeFile);
    return resolvedPath;
}

function getContentsOrExit (file, server) {
    try {
        return fs.readFileSync(file, 'utf8');
    }
    catch (e) {
        const message = e.code !== 'ENOENT' ? e : `No such file: ${file}`;
        server.close(() => { });
        console.error(message);
        process.exit(1);
        return '';
    }
}

var CONFIG_FILE_PATH = null;
function loadConfig (options, server) {
    if (!shouldLoadConfigFile(options)) {
        return Q(server);
    }
    CONFIG_FILE_PATH = options.configfile;
    const configContents = getContentsOrExit(options.configfile, server),
        parsedContents = options.noParse ? configContents : ejs.render(configContents, {
            filename: options.configfile,
            stringify: stringify,
            inject: stringify // backwards compatibility
        }),
        json = JSON.parse(parsedContents),
        // [json] Assume they left off the outer imposters array
        imposters = json.imposters || [json];

    return putConfig(options, JSON.stringify({ imposters: imposters })).then(() => {
        return Q(server);
    });
}

// Build the predicate path string for the given route, replacing
// variables inside {} with regex expressions
function buildPredicatePath (route, basepath, params) {
    if (basepath === '/' || basepath === undefined) {
        basepath = '';
    }
    if (route.includes('{')) {
        let predicatePath = route;
        const matches = [...route.matchAll(/{(.*?)}/g)];
        matches.forEach(fieldName => {
            params.forEach(item => {
                if (item.name === fieldName[1]) {
                    switch (item.type || item.schema.type) {
                        case 'integer':
                            predicatePath = predicatePath.replace(`{${fieldName[1]}}`, '\\d+');
                            break;
                        case 'string':
                            predicatePath = predicatePath.replace(`{${fieldName[1]}}`, '[0-9a-zA-Z-_.~!*\'();:@&=+$\\[\\],?%#]+');
                            break;
                        default:
                            predicatePath = predicatePath.replace(`{${fieldName[1]}}`, '.*');
                            break;
                    }
                }
            });
        });
        return basepath + predicatePath;
    }
    else {
        return basepath + route;
    }
}

// Function that generates a default example according to the entry's type
function getExampleGivenType (type) {
    switch (type) {
        case 'string':
            return '?';
        case 'boolean':
            return false;
        case 'null':
            return null;
        case 'dateTime':
            return '0000-00-00T00:00:00';
        case 'date':
            return '0000-00-00';
        case 'time':
            return '00:00:00';
        default:
            return 0;
    }
}

// Recursive function that builds the response body object iterating through
// the response properties object
function treatProperty (propertyObject) {
    if (propertyObject === undefined) {
        return '?';
    }
    const returnObject = {};
    switch (propertyObject.type) {
        case 'array':
            return treatProperty(propertyObject.items);
        case 'object' || undefined:
            for (let obj in propertyObject.properties) {
                returnObject[obj] = treatProperty(propertyObject.properties[obj]);
            }
            return returnObject;
        default:
            return getExampleGivenType(propertyObject.type);
    }
}

// Function that builds the imposter response from the openapi response object
function buildResponse (respObj, code, statCode) {
    let body, content;
    if (respObj.responses[code].content !== undefined) {
        content = Object.keys(respObj.responses[code].content)[0];
        body = treatProperty(respObj.responses[code].content[content].schema);
    }
    else {
        body = treatProperty(respObj.responses[code].schema);
    }
    const response = {
        is: {
            headers: {
                'Content-Type': respObj.produces || content || '?'
            },
            statusCode: statCode,
            body: body
        }
    };
    return response;
}

/**
 * Creates the stubs structures from the openapi parsed object
 * @param {Object} api - The parsed and validated openapi object
 * @returns {Array} stubs - The constructed openapi stubs array
 */
function buildStubsStruct (api) {
    const stubs = [];
    for (const route in api.paths) {
        for (const verb in api.paths[route]) {
            const predicate = [
                { equals: { method: verb.toUpperCase() } },
                { matches: { path: buildPredicatePath(route, api.basePath, api.paths[route][verb].parameters) } }
            ];
            const response = [];
            for (const code in api.paths[route][verb].responses) {
                const statCode = code === 'default' ? 200 : parseInt(code);
                response.push(buildResponse(api.paths[route][verb], code, statCode));
            }
            stubs.push({ responses: response, predicates: predicate });
        }
    }
    return stubs;
}

// Function to load the OpenAPI file to build the imposter structure
function loadOpenapi (options, server) {
    if (options.openapi === undefined) {
        return Q(true);
    }
    // If the openapi flag is passed but the file path is not
    if (options.openapi === true) {
        server.log('error', 'Swagger/OpenAPI file not passed');
        return Q(true);
    }
    const SwaggerParser = require('swagger-parser');
    return SwaggerParser.validate(options.openapi).then(validatedApi => {
        const fileName = validatedApi.info.title + '.json',
            imposter = {
                imposters: {
                    port: 9090,
                    protocol: validatedApi.schemes !== undefined ? validatedApi.schemes : 'http',
                    name: validatedApi.info.title, // OpenAPI required field
                    stubs: buildStubsStruct(validatedApi)
                }
            };
        fs.writeFileSync(fileName, JSON.stringify(imposter.imposters, null, '\t'));
        server.log('info', `OpenAPI imposter file created with the name  ${fileName}`);
        return putConfig(options, JSON.stringify({ imposters: [imposter.imposters] }));
    }).catch(e => {
        throw e;
    });
}

function serverAt (options) {
    function start () {
        mountebank.create(options).then(server => {
            function shutdown () {
                server.close(() => {
                    try {
                        if (fs.existsSync(options.pidfile)) {
                            fs.unlinkSync(options.pidfile);
                        }
                    }
                    finally {
                        process.exit();
                    }
                });
            }

            process.on('SIGINT', shutdown);
            process.on('SIGTERM', shutdown);

            return loadConfig(options, server);
        }).then(server => {
            return loadOpenapi(options, server);
        }).then(() => {
            // Useful for build plugins that need to wait for mb to be fully initialized
            // They can wait for the pidfile to be written
            fs.writeFileSync(options.pidfile, process.pid.toString());
        }).done();
    }

    function stop () {
        if (!fs.existsSync(options.pidfile)) {
            return Q(true);
        }

        const pid = fs.readFileSync(options.pidfile);
        if (!processExists(pid)) {
            fs.unlinkSync(options.pidfile);
            return Q(true);
        }

        const deferred = Q.defer(),
            startTime = new Date(),
            timeout = 1000,
            waitForClose = () => {
                const elapsedTime = new Date() - startTime;
                if (!fs.existsSync(options.pidfile)) {
                    deferred.resolve();
                }
                else if (elapsedTime > timeout) {
                    try {
                        // For Windows, which doesn't register signal handlers
                        fs.unlinkSync(options.pidfile);
                    }
                    catch (err) { /* ignore */ }
                    finally {
                        deferred.resolve();
                    }
                }
                else {
                    setTimeout(waitForClose, 100);
                }
            };

        process.kill(pid);
        waitForClose();
        return deferred.promise;
    }

    function restart () {
        return stop().then(start).done();
    }

    function logConnectionErrorAndExit (err) {
        const host = options.host || 'localhost';
        if (err.code === 'ECONNREFUSED') {
            console.error(`No mb process running on http://${host}:${options.port}`);
        }
        else {
            console.error(err);
        }
        process.exit(1);
    }

    function save () {
        getConfig(options).then(response => {
            fs.writeFileSync(options.savefile, response.body);
        }).catch(logConnectionErrorAndExit).done();
    }

    function replay () {
        options.removeProxies = true;

        getConfig(options).then(response => {
            if (response.statusCode !== 200) {
                console.error('Received status code ' + response.statusCode);
                console.error(response.body);
                process.exit(1);
            }
            else {
                putConfig(options, response.body);
            }
        }).catch(logConnectionErrorAndExit).done();
    }

    return {
        start: start,
        stop: () => { stop().done(() => { process.exit(); }); },
        restart: restart,
        save: save,
        replay: replay
    };
}

const aliases = {
        d: 'debug',
        h: 'host',
        i: 'allowInjection',
        l: 'localOnly',
        m: 'mock',
        p: 'port',
        r: 'removeProxies',
        w: 'ipWhitelist'
    },
    options = {
        port: {
            default: 2525,
            description: 'the port to run the mountebank server on',
            nargs: 1,
            type: 'number',
            alias: aliases.p,
            global: false
        },
        host: {
            description: 'the hostname to bind the mountebank server to',
            nargs: 1,
            type: 'string',
            alias: aliases.h,
            global: false
        },
        configfile: {
            description: 'file to load imposters from, can be an EJS template',
            nargs: 1,
            type: 'string',
            global: false
        },
        datadir: {
            description: 'the database directory, useful for persistence and performance',
            nargs: 1,
            type: 'string',
            global: false
        },
        noParse: {
            default: false,
            description: 'prevent rendering the configfile as an EJS template',
            type: 'boolean',
            global: false
        },
        pidfile: {
            default: 'mb.pid',
            description: 'where the pid is stored for the stop command',
            nargs: 1,
            type: 'string',
            global: false
        },
        nologfile: {
            default: false,
            description: 'prevent logging to the filesystem',
            type: 'boolean',
            global: false
        },
        logfile: {
            default: 'mb.log',
            description: 'file used for all log',
            nargs: 1,
            type: 'string',
            global: false
        },
        loglevel: {
            default: 'info',
            description: 'level for terminal logs',
            nargs: 1,
            type: 'string',
            choices: ['debug', 'info', 'warn', 'error'],
            global: false
        },
        allowInjection: {
            default: false,
            description: 'set to allow JavaScript injection',
            type: 'boolean',
            alias: aliases.i,
            global: false
        },
        localOnly: {
            default: false,
            description: 'allow connections only from localhost',
            type: 'boolean',
            alias: aliases.l,
            global: false
        },
        ipWhitelist: {
            default: '*',
            description: 'pipe-delimited list of allowed IP address patterns to connect to the mountebank admin port',
            type: 'string',
            alias: aliases.w,
            global: false
        },
        mock: {
            default: false,
            description: 'remember requests for mock verification',
            type: 'boolean',
            alias: aliases.m,
            global: false
        },
        debug: {
            default: false,
            description: 'include stub match information in imposter retrievals for debugging purposes',
            type: 'boolean',
            alias: aliases.d,
            global: false
        },
        savefile: {
            default: 'mb.json',
            description: 'file to save imposters to',
            nargs: 1,
            type: 'string',
            global: false
        },
        protofile: {
            default: 'protocols.json',
            description: 'file to load custom protocol implementations from',
            nargs: 1,
            type: 'string',
            global: false
        },
        removeProxies: {
            default: false,
            description: 'removes proxies from the configuration when using the save command',
            type: 'boolean',
            alias: aliases.r,
            global: false
        },
        heroku: {
            default: false,
            type: 'boolean',
            global: false
        },
        openapi: {
            description: 'openapi file to create imposters and stubs structure',
            nargs: 1,
            type: 'string',
            global: false
        }
    },
    startOptions = {
        port: options.port,
        host: options.host,
        configfile: options.configfile,
        datadir: options.datadir,
        noParse: options.noParse,
        pidfile: options.pidfile,
        nologfile: options.nologfile,
        logfile: options.logfile,
        loglevel: options.loglevel,
        allowInjection: options.allowInjection,
        localOnly: options.localOnly,
        ipWhitelist: options.ipWhitelist,
        mock: options.mock,
        debug: options.debug,
        heroku: options.heroku,
        protofile: options.protofile,
        openapi: options.openapi
    };

const argv = yargs
    .usage('Usage: mb [command=start] [options...]')
    .command('start', 'Starts the server (default command)', startYargs => {
        startYargs
            .usage('Usage: mb [start] [options...]')
            .help('help')
            .wrap(null)
            .options(startOptions)
            .example('mb start --port 3000 --allowInjection --loglevel debug',
                'Starts on port 3000, allowing injections and turning on debug logging')
            .example("mb --ipWhitelist '192.168.1.20|192.158.1.21'",
                'Starts on port 2525 with the given ip whitelist')
            .epilog('Note on the last example that start is assumed if no command is specified\n\nFor more information, see http://www.mbtest.org/docs/commandLine');
    })
    .command('stop', 'Stops the server', stopYargs => {
        stopYargs
            .usage('Usage: mb stop [--pidfile file.pid]')
            .help('help')
            .wrap(null)
            .options({ pidfile: options.pidfile })
            .example('mb stop', 'Stops the process identified in mb.pid')
            .example('mb stop --pidfile test.pid', 'Stops the process identified in test.pid')
            .epilog('For more information, see http://www.mbtest.org/docs/commandLine');
    })
    .command('restart', "Stops the server if it's running and restarts it", restartYargs => {
        restartYargs
            .usage('Usage: mb restart [options...]')
            .help('help')
            .wrap(null)
            .options(startOptions)
            .example('mb restart --port 3000 --allowInjection --loglevel debug',
                'Restarts on port 3000, allowing injections and turning on debug logging')
            .example('mb restart --pidfile test.pid', 'Stops the process identified in test.pid and restarts on port 2525')
            .epilog('The port does not have to match the currently running instance, but the pidfile must match\n\nFor more information, see http://www.mbtest.org/docs/commandLine');
    })
    .command('save', 'Saves current imposter configuration to a config file', saveYargs => {
        saveYargs
            .usage('Usage: mb save [options...]\n\nSaves a snapshot of your configuration, including new responses created by proxies')
            .help('help')
            .wrap(null)
            .options({
                port: options.port,
                savefile: options.savefile,
                removeProxies: options.removeProxies,
                host: options.host
            })
            .example('mb save --savefile config.json --removeProxies --port 3000',
                'Saves the config without proxies into config.json by querying port 3000')
            .example('mb save', 'Saves the config as is into mb.json by querying port 2525')
            .epilog('For more information, see http://www.mbtest.org/docs/commandLine');
    })
    .command('replay',
        'Switches from record mode to replay by removing proxies',
        replayYargs => {
            replayYargs
                .usage('Usage: mb replay [--port 3000]')
                .help('help')
                .wrap(null)
                .options({ port: options.port, host: options.host })
                .example('mb replay --port 3000',
                    'Resets the configuration of mountebank running on port 3000 to remove all proxies')
                .example('mb replay', 'Resets the configuration of mountebank running on port 2525 to remove all proxies')
                .epilog('For more information, see http://www.mbtest.org/docs/commandLine');
        })
    .version()
    .wrap(null)
    .epilog('mb help [command] provides more details\n\nFor more information, see http://www.mbtest.org/docs/commandLine')
    .argv;

function fixAliases () {
    Object.keys(argv).forEach(key => {
        if (aliases[key]) {
            argv[aliases[key]] = argv[key];
            delete argv[key];
        }
    });
}

// Unfortunately, while yargs defaults correctly when the command is present, I couldn't
// figure out how to make it default when the command is absent, which I need to default to start.
// You can set what yargs considers to be the default command by .command(['start', '*']), but
// that changes the help docs in ways I don't want.
function fixDefaults () {
    if (argv._.length === 0) {
        Object.keys(startOptions).forEach(key => {
            if (typeof argv[key] === 'undefined') {
                argv[key] = startOptions[key].default;
            }
        });
    }
}

function fixIPWhitelist (command) {
    if (command === 'start' || command === 'restart') {
        argv.ipWhitelist = argv.ipWhitelist.split('|');
    }
}

// Prevent noise from being logged
function removeNoise () {
    delete argv._;
    delete argv.$0;
    delete argv.version;
}

try {
    const command = argv._.length === 0 ? 'start' : argv._[0],
        server = serverAt(argv);

    fixAliases();
    fixDefaults();
    fixIPWhitelist(command);
    removeNoise();

    switch (command) {
        case 'start':
            server.start();
            break;
        case 'stop':
            server.stop();
            break;
        case 'restart':
            server.restart();
            break;
        case 'save':
            server.save();
            break;
        case 'replay':
            server.replay();
            break;
        case 'help':
            yargs.showHelp();
            break;
        default:
            error(`Invalid command '${command}'.`);
            break;
    }
}
catch (err) {
    error(err.message);
}
